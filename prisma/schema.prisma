generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

model User {
  user_id                   String                     @id @default(uuid()) @db.Char(50)
  email                     String                     @unique @db.Char(50)
  phone                     String?                    @unique @db.Char(50)
  avatar                    String?                    @db.VarChar(255)
  dateOfBirth               DateTime?
  address                   String?                    @db.VarChar(255)
  city                      String?                    @db.VarChar(255)
  country                   String?                    @db.VarChar(255)
  nation                    String?                    @db.VarChar(255)
  bio                       String?                    @db.VarChar(255)
  last_login                DateTime?
  isActive                  Boolean                    @default(true)
  password                  String?
  fullName                  String                     @db.VarChar(255)
  googleId                  String?                    @unique
  role                      Role                       @default(LEARNER)
  gender                    String                     @default("OTHER")
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  accountSecurities         AccountSecurity?
  admin                     Admin?
  chaptersProgress          ChapterProgress[]
  feedbacks                 Feedback[]
  instructor_qualifications InstructorQualifications[]
  instructor                Instructor?
  learner                   Learner?
  lessonsProgress           LessonProgress[]
  note                      Note[]
  specializations           Specialization[]
  submissions               Submission[]
  transactions              Transaction[]
  wallet                    Wallet?
  withdraw_request          WithdrawRequest[]

  @@index([email], map: "idx_user_email")
  @@index([role], map: "idx_user_role")
  @@index([last_login], map: "idx_user_last_login")
  @@index([role, isActive], map: "idx_user_role_active")
  @@index([isActive], map: "idx_user_active")
  @@index([googleId], map: "idx_user_googleid")
  @@index([fullName], map: "idx_user_fullname")
  @@index([phone], map: "idx_user_phone")
  @@index([createdAt], map: "idx_user_createdat")
  @@map("users")
}

model Learner {
  learner_id      String           @id @default(uuid()) @db.Char(50)
  user_id         String           @unique @db.Char(50)
  enrolledAt      DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  createAt        DateTime         @default(now())
  learner_courses LearnerCourses[]
  user            User             @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("learners")
}

model Instructor {
  instructor_id             String                     @id @default(uuid()) @db.Char(50)
  user_id                   String                     @unique @db.Char(50)
  isVerified                Boolean                    @default(false)
  status                    Status                     @default(Inactive)
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  bank_accout               BankAccount?
  citizen_id_confirms       CitizenIdsConfirm?
  courses                   Course[]
  instructor_qualifications InstructorQualifications[]
  instructorSpecialization  InstructorSpecializations?
  user                      User                       @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([status], map: "idx_instructor_status")
  @@index([isVerified], map: "idx_instructor_verified")
  @@index([status, isVerified], map: "idx_instructor_status_verified")
  @@index([createdAt], map: "idx_instructor_created")
  @@map("instructors")
}

model InstructorSpecializations {
  instructor_specialization_id String         @id @default(uuid()) @db.Char(50)
  instructor_id                String         @unique @db.Char(50)
  specialization_id            String         @db.Char(50)
  admin_id                     String         @db.Char(50)
  createdAt                    DateTime       @default(now())
  updatedAt                    DateTime       @updatedAt
  admin                        Admin          @relation(fields: [admin_id], references: [admin_id])
  instructor                   Instructor     @relation(fields: [instructor_id], references: [instructor_id], onDelete: Cascade)
  specialization               Specialization @relation(fields: [specialization_id], references: [specialization_id])

  @@map("instructor_specializations")
}

model Specialization {
  specialization_id        String                      @id @default(uuid()) @db.Char(50)
  instructor_id            String?                     @unique @db.Char(50)
  user_id                  String                      @db.Char(50)
  specialization_name      String                      @unique @db.VarChar(255)
  isVerified               Boolean                     @default(false)
  createdAt                DateTime                    @default(now())
  updatedAt                DateTime                    @updatedAt
  instructorQualifications InstructorQualifications[]
  specialization           InstructorSpecializations[]
  belong_user              User                        @relation(fields: [user_id], references: [user_id])

  @@index([specialization_name], map: "idx_spec_name")
  @@index([isVerified], map: "idx_spec_verified")
  @@map("specializations")
}

model CitizenIdsConfirm {
  citizen_id     String         @id @default(uuid()) @db.Char(50)
  instructor_id  String         @unique @db.Char(50)
  citizen_number String         @unique
  date_of_birth  DateTime
  place_of_birth String         @db.VarChar(255)
  issued_place   String         @db.VarChar(255)
  status         ApprovalStatus @default(Pending)
  isVerified     Boolean        @default(false)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  instructor     Instructor     @relation(fields: [instructor_id], references: [instructor_id], onDelete: Cascade)

  @@index([status], map: "idx_citizen_status")
  @@index([isVerified], map: "idx_citizen_verified")
  @@map("citizen_ids_confirms")
}

model InstructorQualifications {
  instructor_qualification_id String            @id @default(uuid()) @db.VarChar(50)
  instructor_id               String?           @db.Char(50)
  specialization_id           String            @db.Char(50)
  user_id                     String            @db.Char(50)
  type                        QualificationType @default(Certificate)
  title                       String            @db.VarChar(255)
  issue_date                  DateTime
  expire_date                 DateTime?
  issue_place                 String?           @db.VarChar(255)
  qualification_images        String[]
  status                      ApprovalStatus    @default(Pending)
  isVerified                  Boolean           @default(false)
  createdAt                   DateTime          @default(now())
  updateAt                    DateTime          @updatedAt
  instructor                  Instructor?       @relation(fields: [instructor_id], references: [instructor_id])
  specialization              Specialization    @relation(fields: [specialization_id], references: [specialization_id])
  user                        User              @relation(fields: [user_id], references: [user_id])

  @@unique([user_id, specialization_id])
  @@index([instructor_id], map: "idx_iq_instructor")
  @@index([user_id], map: "idx_iq_user")
  @@index([specialization_id], map: "idx_iq_specialization")
  @@index([status], map: "idx_iq_status")
  @@index([isVerified], map: "idx_iq_verified")
  @@index([expire_date], map: "idx_iq_expire")
  @@map("instructor_qualifications")
}

model BankAccount {
  bank_id             String     @id @default(uuid()) @db.Char(50)
  instructor_id       String     @unique @db.Char(50)
  bank_name           String     @db.VarChar(255)
  account_number      String     @db.VarChar(255)
  account_holder_name String     @db.VarChar(255)
  created_at          DateTime   @default(now())
  updated_at          DateTime   @updatedAt
  belongInstructor    Instructor @relation(fields: [instructor_id], references: [instructor_id], onDelete: Cascade)

  @@index([instructor_id], map: "idx_instructor_bank")
  @@map("bank_account")
}

model Wallet {
  wallet_id    String        @id @default(uuid()) @db.VarChar(50)
  user_id      String        @unique @db.Char(50)
  balance      Decimal       @db.Decimal(10, 2)
  createAt     DateTime      @default(now())
  updateAt     DateTime      @updatedAt
  transactions Transaction[]
  belongUser   User          @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([balance], map: "idx_wallet_balance")
  @@map("wallets")
}

model Transaction {
  transaction_id   String            @id @default(uuid()) @db.Char(50)
  course_id        String?           @db.Char(50)
  user_id          String            @db.Char(50)
  wallet_id        String?           @db.Char(50)
  payment_code     BigInt            @unique
  transaction_type TransactionType
  commission_rate  Decimal?          @db.Decimal(5, 2)
  payment_method   TransactionMethod
  amount           Decimal?          @db.Decimal(10, 2)
  currency         String            @db.VarChar(10)
  status           TransactionStatus @default(Pending)
  note             TransactionNote
  description      String?           @db.VarChar(255)
  sender_bank      String?           @db.VarChar(50)
  sender_name      String?           @db.VarChar(100)
  sender_number    String?           @db.VarChar(50)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  course           Course?           @relation(fields: [course_id], references: [course_id])
  user             User              @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  wallet           Wallet?           @relation(fields: [wallet_id], references: [wallet_id])

  @@index([user_id], map: "idx_trans_user")
  @@index([wallet_id], map: "idx_trans_wallet")
  @@index([course_id], map: "idx_trans_course")
  @@index([status], map: "idx_trans_status")
  @@index([transaction_type], map: "idx_trans_type")
  @@index([payment_method], map: "idx_trans_method")
  @@index([createdAt], map: "idx_trans_created")
  @@index([user_id, status], map: "idx_trans_user_status")
  @@index([user_id, createdAt], map: "idx_trans_user_date")
  @@map("transactions")
}

model Admin {
  admin_id                   String                      @id @default(uuid()) @db.Char(50)
  user_id                    String                      @unique @db.Char(50)
  admin_role_id              String                      @db.Char(50)
  createdAt                  DateTime                    @default(now())
  updatedAt                  DateTime                    @updatedAt
  adminRole                  AdminRole                   @relation(fields: [admin_role_id], references: [admin_role_id])
  user                       User                        @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  instructorSpecializations  InstructorSpecializations[]
  withdraw_request_processed WithdrawRequest[]

  @@index([admin_role_id], map: "idx_admin_role")
  @@map("admins")
}

model ResourceType {
  resource_id   String                 @id @default(uuid()) @db.Char(50)
  resource_name String                 @unique
  permissions   PermissionOnResource[]

  @@map("resource_types")
}

model AdminRole {
  admin_role_id String                @id @default(uuid()) @db.Char(50)
  level         Int
  role_name     String                @unique @db.VarChar(255)
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  permissions   AdminRolePermission[] @relation("RoleToPermission")
  admins        Admin[]

  @@map("admin_roles")
}

model Permission {
  permission_id   String                 @id @default(uuid()) @db.Char(50)
  permission_name String                 @unique @db.VarChar(255)
  description     String?                @db.VarChar(255)
  createdAt       DateTime               @default(now())
  updatedAt       DateTime               @updatedAt
  adminRoles      AdminRolePermission[]  @relation("PermissionToAdminRole")
  resources       PermissionOnResource[]

  @@map("permissions")
}

model PermissionOnResource {
  id             String       @id @default(uuid())
  permissionId   String       @db.Char(50)
  resourceTypeId String       @db.Char(50)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  permission     Permission   @relation(fields: [permissionId], references: [permission_id], onDelete: Cascade)
  resource       ResourceType @relation(fields: [resourceTypeId], references: [resource_id], onDelete: Cascade)

  @@unique([permissionId, resourceTypeId])
  @@index([permissionId], map: "idx_por_permission")
  @@index([resourceTypeId], map: "idx_por_resource")
  @@map("permission_on_resources")
}

model AdminRolePermission {
  permission_id    String     @default(uuid()) @db.Char(50)
  admin_role_id    String     @db.Char(50)
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  roleToPermission AdminRole  @relation("RoleToPermission", fields: [admin_role_id], references: [admin_role_id])
  permission       Permission @relation("PermissionToAdminRole", fields: [permission_id], references: [permission_id])

  @@id([permission_id, admin_role_id])
  @@index([admin_role_id], map: "idx_arp_role")
  @@map("admin_role_permissions")
}

model AccountSecurity {
  account_security_id   String    @id @default(uuid()) @db.Char(50)
  user_id               String    @unique @db.Char(50)
  email_verified        Boolean   @default(false)
  failed_login_attempts Int
  verification_token    String?   @db.VarChar(255)
  token_expires_at      DateTime?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("account_securities")
}

model Group {
  group_id       String        @id @default(uuid()) @db.Char(50)
  name           String
  description    String
  type           GroupType     @default(Group)
  discount       Decimal       @db.Decimal(5, 2)
  createdAt      DateTime      @default(now())
  updateAt       DateTime      @updatedAt
  hasCourseGroup CourseGroup[]

  @@map("groups")
}

model CourseGroup {
  group_id       String   @db.Char(50)
  course_id      String   @db.Char(50)
  order_index    Int
  createdAt      DateTime @default(now())
  updateAt       DateTime @updatedAt
  belongToCourse Course   @relation(fields: [course_id], references: [course_id], onDelete: Cascade)
  belongToGroup  Group    @relation(fields: [group_id], references: [group_id], onDelete: Cascade)

  @@id([course_id, group_id])
  @@map("course_groups")
}

model Course {
  course_id          String           @id @default(uuid()) @db.Char(50)
  category_id        String           @db.Char(50)
  level_id           String           @db.Char(50)
  instructor_id      String           @db.Char(50)
  status             CourseStatus     @default(Draft)
  title              String           @db.VarChar(255)
  slug               String?          @unique @db.VarChar(255)
  requirement        String?
  description        String
  thumbnail          String           @db.VarChar(255)
  admin_note         String?          @db.VarChar(255)
  price              Decimal          @db.Decimal(10, 2)
  sale_off           Boolean          @default(false)
  hot                Boolean          @default(false)
  tag                Boolean          @default(false)
  available_language LanguageOptions  @default(Vietnamese)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  chapter            Chapter[]
  inCourseGroups     CourseGroup[]
  category           Category         @relation(fields: [category_id], references: [category_id], onDelete: Cascade)
  instructor         Instructor       @relation(fields: [instructor_id], references: [instructor_id], onDelete: Cascade)
  level              Level            @relation(fields: [level_id], references: [level_id], onDelete: Cascade)
  feedbacks          Feedback[]
  learnerCourses     LearnerCourses[]
  transaction        Transaction[]

  @@index([category_id], map: "idx_course_category")
  @@index([instructor_id], map: "idx_course_instructor")
  @@index([status], map: "idx_course_status")
  @@index([status, category_id], map: "idx_course_status_cat")
  @@index([price], map: "idx_course_price")
  @@index([slug], map: "idx_course_slug")
  @@index([hot, sale_off], map: "idx_course_hot_sale")
  @@index([createdAt], map: "idx_course_created")
  @@index([available_language], map: "idx_course_language")
  @@map("courses")
}

model Category {
  category_id   String   @id @default(uuid()) @db.Char(50)
  category_name String   @unique @db.VarChar(255)
  slug          String?  @db.Char(255)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  is_verified   Boolean  @default(false)
  courses       Course[]

  @@map("categories")
}

model Level {
  level_id    String   @id @default(uuid()) @db.Char(50)
  level_name  String   @unique @db.VarChar(255)
  order_index Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  course      Course[]

  @@index([order_index], map: "idx_level_order")
  @@map("levels")
}

model LearnerCourses {
  learner_id  String                 @db.Char(50)
  course_id   String                 @db.Char(50)
  status      CourseEnrollmentStatus @default(Enrolled)
  progress    Decimal                @db.Decimal(5, 2)
  rating      Int
  feedback    String                 @db.VarChar(255)
  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @updatedAt
  enrolledAt  DateTime               @default(now())
  completedAt DateTime
  course      Course                 @relation(fields: [course_id], references: [course_id], onDelete: Cascade)
  learner     Learner                @relation(fields: [learner_id], references: [learner_id], onDelete: Cascade)

  @@id([learner_id, course_id])
  @@unique([learner_id, course_id])
  @@index([learner_id], map: "idx_lc_learner")
  @@index([course_id], map: "idx_lc_course")
  @@index([status], map: "idx_lc_status")
  @@index([learner_id, status], map: "idx_lc_learner_status")
  @@index([enrolledAt], map: "idx_lc_enrolled")
  @@index([completedAt], map: "idx_lc_completed")
  @@map("learner_courses")
}

model Chapter {
  chapter_id            String            @id @default(uuid()) @db.Char(50)
  course_id             String            @db.Char(50)
  chapter_title         String            @db.VarChar(255)
  order_index           Int               @default(0)
  createAt              DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  belongChapterProgress ChapterProgress[]
  belongCourse          Course            @relation(fields: [course_id], references: [course_id], onDelete: Cascade)
  lessons               Lesson[]
  quiz                  Quiz?

  @@index([course_id], map: "idx_section_course")
  @@index([course_id, order_index], map: "idx_section_order")
  @@map("chapters")
}

model Lesson {
  lesson_id             String           @id @default(uuid()) @db.Char(50)
  chapter_id            String           @db.Char(50)
  title                 String           @db.VarChar(255)
  video_url             String?          @db.VarChar(255)
  duration              String           @db.VarChar(100)
  slug                  String           @db.Char(50)
  order_index           Int              @default(0)
  createAt              DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  belongLessonsProgress LessonProgress[]
  belongChapter         Chapter          @relation(fields: [chapter_id], references: [chapter_id], onDelete: Cascade)
  notes                 Note[]

  @@index([chapter_id], map: "idx_lesson_section")
  @@index([chapter_id, order_index], map: "idx_lesson_order")
  @@map("lessons")
}

model Note {
  note_id      String   @id @default(uuid()) @db.VarChar(50)
  user_id      String   @db.Char(50)
  lesson_id    String   @db.Char(50)
  content      String   @db.VarChar(255)
  createAt     DateTime @default(now())
  updatedAt    DateTime @updatedAt
  belongLesson Lesson   @relation(fields: [lesson_id], references: [lesson_id], onDelete: Cascade)
  belongUser   User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("notes")
}

model WithdrawRequest {
  withdraw_request_id String         @id @default(ulid()) @db.Char(50)
  user_id             String
  admin_id            String
  status              WithdrawStatus @default(Pending)
  note                String         @db.VarChar(255)
  balance             Decimal        @db.Decimal(10, 2)
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  admin               Admin          @relation(fields: [admin_id], references: [admin_id], onDelete: Cascade)
  belongUser          User           @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("withdraw_requests")
}

model Feedback {
  id        String   @id @default(uuid()) @db.Char(50)
  course_id String   @db.Char(50)
  user_id   String   @db.Char(50)
  rating    Int
  comment   String?  @db.VarChar(255)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  course    Course   @relation(fields: [course_id], references: [course_id], onDelete: Cascade)
  user      User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@unique([course_id, user_id])
  @@index([course_id], map: "idx_feedback_course")
  @@index([user_id], map: "idx_feedback_user")
  @@index([rating], map: "idx_feedback_rating")
  @@index([course_id, rating], map: "idx_feedback_course_rating")
  @@index([createdAt], map: "idx_feedback_created")
  @@index([course_id, createdAt], map: "idx_feedback_course_date")
  @@map("feedbacks")
}

model Quiz {
  quiz_id       String       @id @default(uuid()) @db.Char(50)
  chapter_id    String       @unique @db.Char(50)
  title         String       @db.VarChar(100)
  slug          String       @db.Char(50)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  is_completed  Boolean      @default(false)
  questions     Question[]
  belongChapter Chapter      @relation(fields: [chapter_id], references: [chapter_id], onDelete: Cascade)
  submissions   Submission[]

  @@map("quizzes")
}

model LessonProgress {
  user_id      String    @db.Char(50)
  lesson_id    String    @db.Char(50)
  is_completed Boolean   @default(false)
  completed_at DateTime?
  lesson       Lesson    @relation(fields: [lesson_id], references: [lesson_id])
  user         User      @relation(fields: [user_id], references: [user_id])

  @@id([user_id, lesson_id])
  @@unique([user_id, lesson_id])
  @@map("lesson_progress")
}

model ChapterProgress {
  user_id      String    @db.Char(50)
  chapter_id   String    @db.Char(50)
  is_completed Boolean   @default(false)
  completed_at DateTime?
  chapter      Chapter   @relation(fields: [chapter_id], references: [chapter_id])
  user         User      @relation(fields: [user_id], references: [user_id])

  @@id([user_id, chapter_id])
  @@unique([user_id, chapter_id])
  @@map("chapter_progress")
}

model Question {
  question_id String    @id @default(uuid()) @db.Char(50)
  quiz_id     String    @db.Char(50)
  title       String
  order_index Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  answers     Answer[]
  options     Options[]
  belongQuiz  Quiz      @relation(fields: [quiz_id], references: [quiz_id], onDelete: Cascade)

  @@index([quiz_id], map: "idx_question_quiz")
  @@index([quiz_id, order_index], map: "idx_question_order")
  @@map("questions")
}

model Options {
  option_id        String   @id @default(uuid()) @db.Char(50)
  question_id      String   @db.Char(50)
  option_content   String   @db.VarChar(255)
  is_correct       Boolean
  order_index      Int      @default(0)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  choosedByAnswers Answer[]
  belongQuestion   Question @relation(fields: [question_id], references: [question_id], onDelete: Cascade)

  @@index([question_id], map: "idx_option_question")
  @@index([question_id, order_index], map: "idx_option_order")
  @@map("options")
}

model Answer {
  answer_id     String     @id @default(uuid()) @db.Char(50)
  submission_id String     @db.Char(50)
  question_id   String     @db.Char(50)
  option_id     String     @db.Char(50)
  is_correct    Boolean    @default(false)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  choosedOption Options    @relation(fields: [option_id], references: [option_id])
  ofQuestion    Question   @relation(fields: [question_id], references: [question_id], onDelete: Cascade)
  ofSubmission  Submission @relation(fields: [submission_id], references: [submission_id])

  @@unique([submission_id, question_id])
  @@map("answers")
}

model Submission {
  submission_id String   @id @default(uuid()) @db.Char(50)
  quiz_id       String   @db.Char(50)
  user_id       String   @db.Char(50)
  is_completed  Boolean  @default(false)
  duration      String   @db.VarChar(100)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  submittedAt   DateTime @default(now())
  answer        Answer[]
  belongQuiz    Quiz     @relation(fields: [quiz_id], references: [quiz_id], onDelete: Cascade)
  belongUser    User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@unique([quiz_id, user_id])
  @@index([quiz_id], map: "idx_submission_quiz")
  @@index([user_id], map: "idx_submission_user")
  @@index([quiz_id, user_id], map: "idx_submission_unique")
  @@index([submittedAt], map: "idx_submission_date")
  @@map("submissions")
}

enum Role {
  LEARNER
  INSTRUCTOR
  ADMIN
}

enum Status {
  Active
  Inactive
  Suspended
}

enum ApprovalStatus {
  Pending
  Approved
  Rejected
}

enum QualificationType {
  Degree
  Certificate
}

enum CourseEnrollmentStatus {
  Enrolled
  Completed
  Cancelled
  Progressing
}

enum CourseStatus {
  Draft
  Published
  Pending
  Archived
}

enum LanguageOptions {
  English
  Vietnamese
}

enum TransactionType {
  Withdraw
  Deposit
  Pay
  Refund
}

enum TransactionMethod {
  Credit_Card
  Voucher
  Bank_Transfer
  PayPal
}

enum TransactionStatus {
  Pending
  Success
  Cancel
  Refund
}

enum WithdrawStatus {
  Success
  Pending
  Rejected
}

enum TransactionNote {
  User_Pay
  Pay_For_Instructor
}

enum GroupType {
  Combo
  Group
}
